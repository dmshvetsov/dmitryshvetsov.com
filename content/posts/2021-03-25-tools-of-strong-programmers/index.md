---
title: "[working title] tools of strong programmers"
slug: "tools-of-strong-programmers"
author: "Dmitry Shvetsov"
date: "2021-03-25"
hero: images/hero.jpg
---

**Translactions: [RU](/ru-tools-of-strong-programmers)**

## How to take the path to a strong programmer, answers of programmers from Facebook, Amazon, Microsoft and other

How will change how you program if you learn how other programmers have become strong, how they solve problems, and what tools they are using?

For me it all started with the idea of inherit the experience of programmers from my environment. I found out from my friends and former colleagues whom they consider to be strong programmers, I made a list, I prepared questions and started asking them.

I didn’t want to limit myself on my surroundings and therefore I added a question “who do you think is strong?”, And then asked to introduce me to these programmers. This approach worked great! I was lucky to get answers and talk personally with the people from the thought of talking with whom I had a healthy ecstasy.

Although the title includes companies with big names, I did not aim to ask programmers only from well known top companies. I found that valuable advice was given to me on an equally from people who work in companies that are known only in the regions.

On this page, you will learn about rare nuggets and the mundane things that make a strong programmer strong.

## How To Read This Article

In the text you will find _[My Thoughts] in italics_, these are the places where I share my thoughts in addition to the answers.

> “Quotes are given in this style” - Dmitry Shvetsov

In square brackets [like these] I supplement the quotes with my own words so that the meaning is clear, many quotes taken out of context are difficult to understand as the author of the quote wanted.

The rest of the text is distilled answers and thoughts of the heroes of this article. In most cases I have used the original words and my job here is only to summarize and highlight the most important.

Therefore, I want to say a huge thank you to everyone who agreed to share their path in programming. A list of them is at the very end of this article. Some wished to remain anonymous.


## What's make the difference between a mediocre programmer and a strong one?

Strong programmers started early in high school. At that time, information was lacking and it was necessary to programming a lot to become proficient in it. This was the case for Denis Bazhenov, Dmitry Fedorenko and one developer who worked for FAANG companies.

The complexity of modern development is that now the developers toolkit is huge and continues to grow and become more complex. There is a lot to know.

> “The volume of knowledge in the industry is growing, but people have the same time and this is not their fault” - Denis Bazhenov

Strong programmers love to dig deeper through the programming language into the platform and into the hardware, disassembling the code piece by piece, going down and down the layers of abstraction, from the software layer to the hardware.

When the program does not work as we want, and this happens all the time, the ability to debug allows you to move at a constant speed, despite the constant tendency of systems to become more complex.

When a programmer needs to look at a program not from the point of view of the programmer, but from the point of view of the language, the ability to use a debugger on the one hand and the operating system and diagnostic tools on the other hand will come in handy. This allows you to see the big picture, like what files are open, what is happening in memory, what is going on in CPU, what packets are moving across the network. Knowledge of DevOps helps in this regard.

If you are a backend developer then learn operating systems, know C and C++ languages ​​in which most of the system things are written. If you are a Java developer, learn the JVM and the standard library. If you write OOP understand OOP. This forms the very depth of knowledge, helps to write meaningful and pefrormant code. If you are using the database, go further than learning SQL, figure out how they work inside. This will aid in design, bottleneck awareness, and debugging.

Strong programmers don't take facts for granted. They ask the questions "why is this so?" It's great if there is a colleague who has an answer to “why?”, but his absence does not stop a strong programmer, he is driven by curiosity.

Curiosity leads deeper. If something doesn’t work as you expect, or you’re just wondering how this or that function works, you look into its source code, then get deeper, even further from the application layer, you descend to the level below. This knowledge gives an outlook to help solve complex problems.

It's important to be proficient in patterns. This is how Anton Kireev from Avito explains it.

> “Programming is like playing chess. You cannot sit down and start playing chess by learning only how the pieces move. Of course, there will be people who can do this, but in most cases these people, being able to multiply huge numbers in their minds and cannot even put on pants without help. The funny thing is, chess is patterns that your brain won't see at first. That is why it is recommended to play small plays not the full game for the first year. So that the current state of the game is somewhere on your subconscious, at the level of reflexes. [And then you] could [be] with ease engaged in strategy. Without practice, neural connections will not appear in the brain, you will not be able to freely see and apply patterns to the task that you are facing and to the code that you see."

Strong programmers prioritize business, not code, and this changes the way they approach problem solving and technology choices.

Moving from an engineering mindset to a product one is very helpful in efficiency. We must put business at the forefront. Ruslan Torobaev shared his observation.

> “Choose effective solutions, even if they are not always the best, they are faster to make and easier to throw away - Ruslan Torobaev

In developing large products, you often have to throw away your work. Development through experiments and small steps helps to negate this problem.

> “Experiment more, go in small steps” - Ruslan Torobaev

A frequent piece of advice from strong programmers is not to get hooked on hype technologies if you are a product programmer. New technologies with exciting success stories are the same: “they took top-end hardware, new technology, got a dizzying result”.

The stories with failures are much more interesting, says Ruslan, they allow you to find out where the technology cannot be applied, in which cases it does not solve the problem, what bugs it has.

Strong programmers are progmatic. You don't always need an elegant solution, which is written about in books and talked about at conferences.

From Ruslan's experience, it often happens that a prototype that gets to production often works unchanged for months.

Vlad Popov, an architect from Kinaxis, at the beginning of his journey used a PHP script with one class of 25 lines for 2 years as a backend for Flash projects.

Strong programmers are distinguished by the ability to solve situations that block progress on a task. They are not afraid to ask colleagues questions and ask for help.

Ruslan says that psychological moments play a big role.

Personal life problems immediately lead to a drawdown at work. Therefore, balance in life outside of work is as important to a career as the work itself.

_[My thoughts] Health, relationships, financial security are the foundation for everything else._

Another point in psychology is that strong programmers are not afraid to change someone else's code. This is often the case when a programmer starts working on a new project.

> "Don't be afraid to change someone else's code." - Ruslan Torobaev

You have to understand that the code was written before you by programmers like you who solving a local problem and had local knowledge about the system and the product.

Self-confidence is another psychological trait of a strong programmer that helped Vlad.

When you are sure that you are a strong programmer, regardless of experience, it helps in interviews, in working communication, writing code and comment in code reviews.

_[My thoughts] I have moments when I doubt whether I made the right decision, such doubts take away a lot of "mental fuel", which we have in limited quantities for the day._

Write projects to gain confidence. Lots of projects. Build your portfolio and make it public. What was a few nights of programming for you will be like "wow, did you write this?" This is the effect of public portfolios.

_[My thoughts] I got into the first serious company thanks to a portfolio of one project._

6 out of 11 programmers who gave answers to this article [in my opinion] have a noticeable modesty.

> “I developed the habit of considering myself not smarter than the rest, so there were a lot of people who can correct me, and give a slap on back of my head &lt;I hope there is better phrase for this in Enlish :)>. It doesn't matter is it a junior developer or Linus Torvalds. Anyone can teach me something." - Anton Kireev

Programmers are not the kind of people who make money for business despite being well paid. The thought that you get paid more than many of your colleagues can lead to arrogance. This could cause problems, Ruslan warns. Arrogance only gets in the way.

_[My thoughts] We don't make money personally, but we can lose $ 460 million in 45 minutes. Here is the story of how the largest US stock trader went bankrupt due to a dead piece of code._ https://dougseven.com/2014/04/17/knightmare-a-devops-cautionary-tale/

A strong programmer has a tech stack which he uses to solve problems fast, as they have done it many times.

All of the above is united by love for what you do and the desire to work not alone.


## What is the path of a strong programmer?

> “Do what you love, love what you do” - common sense

_[My thoughts] below are many ways to grow into a strong programmer. Some advice contradicts with others, and that's okay. There is no one and only way. Everyone has their own path. It is important to choose the one that will be a pleasure for you so you can enjoy the path._

Work in the field of information technology [hereinafter IT] is a constant race for knowledge. The systems that we as programmers most often work on tend to become more complex, with growing layers of abstraction over abstractions and the integration of everything with everything. Solving problems in such an industry which always requires more knowledge than you have now. You are constantly learning something new.


### Seeking for the feeling of an imposter

> “If you're the smartest person in the room, you're in the wrong room” – Confucius

Your goal is to get into a strong team. When you find yourself in a strong environment, it motivates you to rise to the level of the environment.

_[My thoughts] considering joining a company with a strong engineering team is a good way to find your next job._

> “seek to work with people who know more than you in any area, watch how they work and learn.” - Dmitry Fedorenko

Try to work at the best company you can find. If you can't do that, practice and get really strong with fundamental concepts. There are many resources these days such as online courses, youtube, open -source projects. [About self-development is written further].

Avoid teams and companies with a toxic atmosphere. It is hard to learn and grow in such companies.

If you disagree with the idea that you are constantly learning something, then it's time to think about changing your project or employer. If you do not grow, it hurts you and your colleagues.

> “New environment equals new knowledge” - Ruslan Torobaev

Feedback is a requirement for personal growth. It's harder to grow without feedback. If you don't recieve feedback, ask for it.

_[My Thoughts] 1:1 is an indispensable tool for sharing feedback both from leadership roles to developers and from developers to leadership roles._

A lot of time will have to be spent on training and without enjoying the process it will be hard labor.

If you are interested in programming and you are ready to spend weekends and evenings on it, doing something for fun or code for free - most likely you will turn out to be a good programmer. And vice versa - often the guys who sit at work from 9 to 5 and do not practice outside of it as a hobby, rarely become top and average specialists.

> “It is difficult to be successful in IT if you come there for money and hype. It must be a calling." - Dmitry Fedorenko

> “Simple question - will you program if you won’t be paid for it? If not, then my path not for you "- Dmitry Fedorenko

A good place to start is a position of a web developer in a web studio. This is often а place where juices are squeezed out of you, but they take junior developers with base skills, teach, give a range of experience, build a habit of making tasks in estimate. These are all important skills.

Choosing a company is difficult. A lot of people work in top big companies and getting a job there is a lottery. You can get to the wrong project, or to the wrong leader, or to a weak team.

_[My thoughts] It's a little easier in smaller companies, especially with foreign ones. Through glassdoor and https://www.teamblind.com/company, you can get feedback from former and current colleagues. Let me emphasize again that this approach does not work for large companies. But you can find contacts of current colleagues and communicate in an informal setting, find out if the company has what you are looking for._


### Where challenging task there are strong teammates

> “No pressure, no diamonds.” – Thomas Carlyle

Start participating in large, technically complex (not to be confused with logically complex) projects and / or participate in internship programs of top tech companies as early as possible.

The path to strong programmers is through challenging tasks. This is often the complement to strong colleagues. Where difficult tasks there are strong colleagues.

An ideal situation to get into a strong team where you are mentored and receive help in case of difficult problems.

_[My Thoughts] I noticed how much my colleagues and I grew when they were inside of tight deadlines on a challenging task. That case when you have no choice but to learn how to solve a problem at hand here and now. At such moments, you really turn on to the fullest. And when the task is completed, you feel that you are head and shoulders above your yesterday's self._

Look for projects and challenges, get out of your comfort zone when you feel like doing routine tasks all the time. If you cannot find challenging tasks - change the project or the team. Changing jobs is another way to get out of your comfort zone and into a place of growth.

_[My thoughts] Don't expect every task to be challenging and interesting. Doing a routine is a necessary. It is in your power to make the task more interesting. For example you can make a routine task for speed or hone any other hard or soft skill like athlete._

Follow your interests. Choose a company where working on a product will be super interesting for you and it’s more about industry or domain and less about technologies.

_[My Thoughts] In the long run, an interesting job may be more important than a pay raise now_.


### Self-Development

> “Without great teammates, it is difficult to engage in self-development” - Ruslan Torobaev

You can find smart people outside work place.

Open-source is the most accessible source of the very best programmers who will “show” their code, their tricks and give feedback on your code. It is impossible not to use this opportunity in the absence of strong colleagues. Open-source is a source of knowledge and new acquaintances.

Read a lot of code. Open the library you are using and just read it through.

> “Any solution is a pattern that I have been solving for 11 years, and which has been replenished with knowledge on questions like "how Google works", how this works, how that works." - Anton Kireev

Vlad Popov shares a common threat that modern programmers write non-ideomatic code. It does not match the libraries used in the project. Take a look inside the libraries you are using, figure out how they are written and use this knowledge to write better code.

Vlad believes that he was helped by the habit of trying all experimental technologies as soon as they appear. So you can become one of the experienced specialists in successful technology.

_[My thoughts] He was one of those who stoked up for Node.JS even before the 1st version and used Vue.js in production 5 years ago, when the framework was not yet so popular. Now he is an expert in these two._

On the other hand Denis Bazhenov believes that it is necessary to keep the size of the stack small, not letting it grow. Don't chase every technology that is popular today. Use the freed up time to study your stack in depth.

It often happens that strong companies require deep knowledge of the language and platform, as opposed to the fact that often novice programmers study frameworks and libraries.

Anton Kireeva laid out the idea of ​​teaching programming by copying others in comparison with learning to play the guitar as follows.

> “You can watch tabs [tablature - chord notation for guitarists] of other people's cool songs, like the code of cool programmers and extract patterns by honing their performance by repeating them in your work. But repeating "songs" of other performers you will not learn to play a Spanish piece. To play something like that, you need someone to teach you how to sit, the correct position of the hands, the correct clamp. Why is it important? Because with the right technique, you will get better sound and fatigue less. ”

Sources of self-development by Vadim Tsesko developer from odnoklasniki.ru:



*   reading academic articles
*   tech books
*   conference talks
*   participation in regular meetups and user groups
*   online courses
*   open-source projects, bugs / features, code review

Do not rely on learning only through courses and books. They will not help you go beyond the scope of the studied stack, to the OS and network, where problems most often arise.

In an interview with George Hotz, the developer of iOS jailbreaks who working on the comma.ai autonomous cars project said “you never learn to program by watching a video called “learn programming”.” https://www.youtube.com/watch?v=NjYICpXJ03M

> “Books that will reveal to you the "secret of the whole world" do not exist. All the books I've read give me a maximum of 60% of the information I have." - Anton Kireev

_[My thoughts] the rest is derived from personal experience and the experience of colleagues_

Anton Kireev recommends books by Andrew Tanenbaum for development deep into the technological stack https://duckduckgo.com/?q=Andrew+Tanenbaum+books.

Reading documentation is another source of knowledge. There you can find information about how things work.

leetcode.com is the most recommended resource to get better at basics of computer science.

Ruslan agrees that self-development is possible, but believes that a University will be a better choice. Programming requires a good foundation: higher mathematics &lt;or calculus?>, combinatorics, algebra, operating systems, networks, knowledge of hardware, without formal education it is more difficult to get this knowledge. This does not prevent you from creating web sites, but the lack of this knowledge limits you.

Vlad advises looking at features in new programming languages, they take into account the problems faced by previous generations of programmers.

To learn something new, you need to choose a programming language that will unsettle you, share Denis. It should be completely different from what you use on a daily basis. This approach will expand your arsenal.

It is equally important for growth to be open to criticism considers one of the Facebook programmers.

_[My Thoughts] The hardest part of the previous tip is to really notice when you get hurt &lt;or insult?> and shut yourself off from criticism. At this moment, the brain does not work rationally and you are playing defense. Learning to catch such moments and take advice is another important soft skill. One of my tools for introspection is to write a “day review” in my diary just before bed. I’ve picked this tool from a Stoic, philosopher, and Roman statesman Lucius Seneca._

_[https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D1%86%D0%B8%D0%B9_%D0%90%D0%BD%D0%BD%D0%B5%D0%B9_%D0%A1%D0%B5%D0%BD%D0%B5%D0%BA%D0%B0](https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D1%86%D0%B8%D0%B9_%D0%90%D0%BD%D0%BD%D0%B5%D0%B9_%D0%A1%D0%B5%D0%BD%D0%B5%D0%BA%D0%B0)_

Denis Bazhenov sees a big plus when programmers know about system administration and advises to read the Linux Performance blog http://www.brendangregg.com/linuxperf.html from Netflix Senior Performance Architect Brendan Gregg.

For Java developers, Ruslan Torobaev advises an excellent resource https://shipilev.net/


### Pet projects

Denis Bazhenov believes that he was greatly helped by building a chat project for a university on which he worked with Dmitry Fedorenko.

It was often noticed that it is better to work with someone on pet project and not only. It is difficult to work on long project as a single peson. You will get bored at some point, the fuse always disappears. This happens less often when working in a team.

Vlad Popov undertook any proposal to work on the project. He never said no to a work opportunity. A bunch of projects for no money at all, just for experience, interest, references and acquaintances.

> “I constantly had a bunch of projects at the same time. I was hungry for them. ” - Vlad Popov

Working on various projects helped Vlad to master his tech stack. Start 25 projects from scratch and you will make this process seamles.

In one of the companies, Vlad had a hundred dead repositories. And last year, when he replaced a laptop, he had to copy the folder with the code of projects 25 GB in size.

_[My thoughts] Four years ago we worked together on a project and he was looking for a library to solve a problem. “Dima, look” he said, “well written… that is clever… it’s cool too… hmm here I would write differently, but fine… I wonder who is the author?” He opens the project's config file, scrolls down and sees that he is the author._

Vadim Tsesko gives advice to write just for fun your own implementation of various layers of the technological stack: boot file, kernel, network, data structures, library and framework. This will give a better understanding of the entire stack that programmers rely on every day.


### Mentorship

> “When the student is ready the teacher will appear. When the student is truly ready... The teacher will Disappear.” – Tao Te Ching

A mentor can turn years of self-study into weeks and months into days.

Vlad Popov missed classes at university. Instead, he went to study with a person who knew the technology he was interested in better than anyone else in his country. Denis Muraviev conducted an intensive course on Flash, where designers, after a few days, were able to write ActionScript code [a relative of ECMAScript].

> “When they explained to me what classes are, I didn’t understand why they were needed, you can write procedures instead” - Vlad Popov

Subscribe and follow the cool developers on Github and Twitter, follow the Core developers on your stack.

Their example of how to write good code will inspire you to grow up all the time and find extra time for your hobbies, keeping you moving forward.

_[My Thoughts] The mentor may not know that he is your mentor. By reading his blog, Twitter, listening to podcasts and watching screencasts and videos on YouTube, you can learn a lot from the programmer. Vova Popov and I took over the previously popular TextMate editor and learned how to develop on the Ruby on Rails framework. Choose 2-3 strongest in your field, read all the content that they publish._

Denis Bazhenov himself is a mentor for young teammates. He shared what to look for when choosing a mentor:



*   Prefer highly specialized ones who have been digging into their topic for a long time in which you want to learn from them
*   Avoid people who are critical in their thinking
*   Knows not only the pros but also the cons of the technology you want to learn from a mentor

And how to be a good student for a mentor:



*   Don't be indifferent, you should be interested
*   Doing anything outside 9 to 5 job, like open source, pet project, writing a blog
*   Ability to perceive an idea opposite to the one in your head


### What if you're just starting out?

Novice programmers should get their hands on programming as much as possible. They should be able to follow the leader.

The goal is to be as useful as possible without constant questions and be able to solve a well-posed problem on your own.

This stage went through quite fast.

The next step is to broaden your horizons. Code review, git, debugging, DevOps, problem solving [read about problem solving below]. Developing on these domains you become self-sufficient.

The following traits help beginner programmers realize their potential:



*   internship in teams with challenging tasks and experienced colleagues
*   drive
*   own ideas
*   susceptibility to criticism
*   ability to be led


### How to find time for all this?

Nobody cancels the hard work.

> “The threshold for entering programming and IT in general is big. 5-10 years you need to work hard to become an average specialist. We must arrange for ourselves periodically sweatshops ”- Dmitry Fedorenko

> Direct all free time to self-development - Vadim Tsesko

Many have families and children. How to find time for at least some of the above?

The main secret is a strong inner desire. Do what you love, love what you do. You will always find time for something that makes you happy.

> “I don’t know, it’s itself &lt;or it happens themself, or it just works, or it is just happens>” - Anton Kireev


## Tools and Tricks of Strong Programmers

Dmitry Fedorenko uses Get Thing Done practive [https://en.wikipedia.org/wiki/Getting_Things_Done](https://en.wikipedia.org/wiki/Getting_Things_Done).

Invest time in learning how to use debuggers. Debaguerres are very helpful in quickly understanding what's going wrong. This will help in resolving bugs and in development when the code stopped working the way you wanted it to.

Analytical debugging [term not mine, it is from develpers at JetBrains]. It's a way to ditch debuggers and think about what went wrong. The advantage of this approach is that with its help it is more likely to find the sources of the problem, and not its symptoms, you have a growing general understanding of the project, you can find accompanying bugs. The disadvantage of the analytical debugging is that it is many times slower than using debuggers.

OS debugging tools that Denis Bazhenov uses:



*   strace
*   ltrace
*   pidstat
*   tcpdump
*   linux sar
*   lsof
*   vmstat

Advantage of these diagnostic tools is that they allow you to understand what is happening with the application, regardless of what language the application is written in.


## Solve Problems like a PRO

> “The problems are all different, but they all boil down to the same tasks” - a programmer from JetBrains

There are no secrets in solving problems. Use decision theory and standard problem solving approach.

Notice patterns, the faster you identify them, the faster you will be able to solve problems.

The whole approach to problem solving is an optimization problem with some pretty tricky boundary conditions. Therefore, the most difficult part of this process is to choose the best solution.

Do not blindly believe the description of the problem. Before solving it, you need to understand it well. Find out exactly who needs it and why. This requires asking questions. In a third of the cases, the task may disappear altogether, in the other third it may change very much.

> \- Dmitry, make a green button here.
> \- No, first describe what problem you have? Why it is a button? What will happen if we won’t do this?

This approach is very energy saving. Often, before starting work, it turns out that you do not need a button, but a link, or text on the page, or you do not need to do anything at all. Better to spend time on conversation first, and then programming.

“Lack of requirements is a constant problem that I face.” - Dmitry Fedorenko

Break down complex problems into small manageable chunks, the details of which can easily fit in your head and which you can complete in 4 hours.

> “Small libraries are more useful than one big one. An ideal library is a library that you can write in 4 hours and forget about it. " - Vlad Popov

Big tasks take hours to dive into every time you start working on it. Avoid context switching, small tasks help with this.

Try to apply first principles and find the best solution to the problem without considering the constraints.

Try to use first principles and think of what is the best way to solve a problem apart from constraints. Consider trade-offs between different solutions and bias towards simplicity. [https://fs.blog/2018/04/first-principles/](https://fs.blog/2018/04/first-principles/)

Try to assemble a minimum working prototype. Do not care about the quality and usage of best tool like databases, queues, etc. Do it in a short time frame to see how the feature works and get feedback on it from users.

Look for the shortest path to a solution.

> “When I was inexperienced, I wanted to do everything in the best possible way, and I started, as it seemed to me, to" build a bridge "thoroughly from one end. But over time, I realized that such bridges end up in the wrong place. Therefore, with experience, I first "tread the path", making at least some working prototype, then, when (and if) this stuff somehow works, I begin to grow meat arround it. " - a programmer from ok.ru

_[My thoughts] When you have a ready-made goodenough solution, the deadlines are no longer pressing on you. Here you can make a decision to improve something, get feedback on the code, or save time for another task. Trying to make it sleek right away, I often ended up missing a deadline._

Consider the requirements and resources that you have. Some tasks require immersion in the subject area, while others are a waste of time.

Use analytics, it is useful for business, monitoring, debugging.

When you don't know how to solve a problem, make the simplest solution possible. Up to `if a = some_value then return expected_result`. You need just to start. Solve the next step from the requirements in the problem as having the simplest solution. Keep going with the next requirements.

Often tasks that you do not know how to solve are obviously solvable. The solution for them comes from an intensive search on the Internet. The downside of this approach is that it takes a lot of time, days and weeks.

Tasks that are not give in to you, can be postponed for a couple of hours or until tomorrow. Fall asleep with a difficult task in mind, often the idea comes in the morning.

_[My thoughts] this is due to the fact that our brain works in two modes, focused and diffused. Focused mode allows us to keep more complex details in our head. It's more about depth of knowledge. Whereas the diffuse mode is a creative work mode using the full breadth of our knowledge. New ideas come in diffuse mode, in which the brain works in the background. This explains the belief that ideas come in the shower._

A detailed list of the approach to problem solving was shared by Vadima Tsesko:



1. Collection of all requirements, immersion in the domain
2. Thorough documentation (design doc) for subsequent retrospection of maintanace and development of the system
3. Search and communicate with colleagues with relevant experience in order to collect an exhaustive set of alternatives
4. Study of existing solutions in the market, read academic articles (if relevant)
5. Analysis of the advantages and disadvantages of each of the solution options, the choice of the solution
6. Iterative design review and gathering opinions from more experienced colleagues
7. Important: to be isolated and not get hung up, proactively collect opinions, be open and tolerant of criticism, honestly weigh the pros and cons, rely on rationality and data

Tips from Denis Bazhenov:



*   conceptualize the task in terms of technical and business constraints, under what conditions a solution will not work
*   if the task is not demanding on resources, then the approach to make a prototype is through automated tests, it is easier to form a design and many flaws are seen earlier
*   if the task is technically complex or related to distributed systems, it is important to analyze what can fail, what steps need to be taken to make the system diagnosable, what we will do if parts of the system start to fail, how to eliminate failures, how to be on the safe side, for example Veda special logs
*   when everything fits together it comes to programming, an understanding comes into which modules the system should be divided, how to organize work
*   consider making a prototype (maybe even without programming)

On how to implement the decisions made by Ruslan Torobaev:



*   Write unit tests if the task is large and it is not possible to keep all its parts in your head.
*   Use specialized logs for integration code. It is not possible to cover everything with tests in integrations.
*   For small components, the TDD approach is useful. It helps to find flaws in the interface. If the component cannot be tested, you immediately understand that you need to change the interface.

It is important to be able to solve blocks while working on a task. Here are the steps on how to do it:



1. Use internal knowledge base or documentation, external product documentation
2. Help from colleagues
3. StackOverflow, Slack community channels, Discord, User Groups, issues in a library or product repository, product channels.
4. look into the source code. For 3rd party products you can fetch a Docker image, start debugging with breakpoints and see how the product works from the inside. You can use #4 point simultaneously with #1, #2, and #3


## More To Come

By the time when I need to publish this article, I have even more programmers on my list with whom I want to contact and ask my questions than when I started this idea.

This page will be updated over time.

Subscribe to the mailing list for this article to find out when there will be new answers. &lt;link to convertkit form>


## Heroes of this article

Many thanks to the guys for the answers and for the interesting communication.



*   Anton Kireev, a programmer at Avito
*   Denis Bazhenov, a tech lead at Farpost
*   Dmitry Fedorenko, CTO at 100sp.ru
*   Roman Dmitrienko, team lead at Drom.ru
*   Ruslan Torobaev, team lead, at ok.ru
*   Vadim Tsesko, a programmer at ok.ru
*   Vlad Popov, architect at Kinaxis

Asked to remain anonymous:

*   a programmer from Facebook
*   an ex. Amazon, ex. Microsoft programmer
*   a programmer from JetBrains
*   a programmer from ok.ru


# [Non content notes]

title image candidates:
* https://unsplash.com/photos/XX9K9EfBVog
* https://unsplash.com/photos/H2kyVtTjLfU
